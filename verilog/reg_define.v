`timescale 1ns / 1ps


// $Id$
// This file was generated by regmaker.pl

module reg_define (
  output reg [ 1:0] turn_on_signal, // start_sytolic_array
  output reg [5:0] budget, // input_acc_size
  output reg [31:0] systolic_width_size, // systolic_width_size 
  output reg [31:0] systolic_height_size, // systolic_height_size 
  output reg [31:0] input_xin_width_size, // input_xin_width_size 
  output reg [31:0] input_xin_height_size, // input_xin_height_size 
  input      [31:0] write_data    ,
  input      [15:0] addr          ,
  output     [31:0] read_data     ,
  input             write         ,
  input             read          ,
  input             clk           ,
  input             reset_n
);

  wire [15:0] addr_1      ;
  wire [31:0] write_data_1;
  reg  [31:0] read_data_1 ;
  wire        read_1, write_1;

  assign addr_1       = addr;
  assign write_data_1 = write_data;
  assign write_1      = write;
  assign read_1       = read;
  assign read_data    = read_data_1;


// read data is available in the same cycle as when addr is applied
// write data is available 1 cycle after addr is applied

  always @(posedge clk or negedge reset_n) begin
    if (!reset_n) begin
      turn_on_signal <= 2'b0; // turn on the hese encoder and comparator
      budget <= 5'b0; // input_acc_size
      systolic_width_size <= 32'h00000000; // systolic_width_size 
      systolic_height_size <= 32'h00000000; // systolic_height_size 
      input_xin_width_size <= 32'h00000000; // input_xin_width_size 
      input_xin_height_size <= 32'h00000000; // input_xin_height_size 
    end
    else begin

      if (write_1) begin
        case(addr_1[15:0])
          16'h0000 : begin  // start_sytolic_array
            turn_on_signal[1:0] <= write_data_1[1:0];
          end
          16'h0004 : begin  // input_acc_size
            budget[5:0] <= write_data_1[5:0];
          end
          16'h0008: begin  // systolic_width_size
              systolic_width_size[31:0] <= write_data_1[31:0];
          end
          16'h000c: begin  // systolic_height_size
              systolic_height_size[31:0] <= write_data_1[31:0];
          end
          16'h0010: begin  // input_xin_width_size
              input_xin_width_size[31:0] <= write_data_1[31:0];
          end
          16'h0014: begin  // input_xin_height_size
              input_xin_height_size[31:0] <= write_data_1[31:0];
          end
        endcase
      end
    end
  end
// Reads...
  always @* begin
    case(addr_1[15:0])
      16'h0000 : begin // sytolic_array_idle
        read_data_1 = {{(30){1'b0}},turn_on_signal[1:0]};
      end
      16'h0004 : begin // input_acc_size
        read_data_1 = {budget[5:0]};
      end
      16'h0008: begin // systolic_width_size
        read_data_1 = {systolic_width_size[31:0]};
      end
      16'h00c: begin // systolic_height_size
        read_data_1 = {systolic_height_size[31:0]};
      end
      16'h0010: begin // input_xin_width_size
        read_data_1 = {input_xin_width_size[31:0]};
      end
      16'h0014: begin // input_xin_height_size
        read_data_1 = {input_xin_height_size[31:0]};
      end
      default : read_data_1 = {16'hdead,addr_1[15:0]};
    endcase
  end

endmodule
